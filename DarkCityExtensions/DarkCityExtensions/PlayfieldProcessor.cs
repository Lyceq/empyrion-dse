using DarkCity.Data;
using DarkCity.Tokenizers;
using Eleon.Modding;
using System;
using System.Collections.Generic;
using System.Threading;

namespace DarkCity
{
	/// <summary>
	/// Processes an IPlayfield instance at regular intervals. Responsible for dispatching interesting bits of the playfield to feature handlers. Processing is performed in a separate thread.
	/// </summary>
	public class PlayfieldProcessor
	{
		/// <summary>
		/// The IPlayfield that this processor handles.
		/// </summary>
		public IPlayfield Playfield { get; }
		public PlayfieldTokenizer PlayfieldTokens { get; private set; }

		/// <summary>
		/// Resolution of maps generated by this processor. A higher number results in a smaller map. Refer to <see cref="PlayfieldMap.Resolution"/>.
		/// </summary>
		public float MapResolution { get; set; } = 10;

		public int SizeClass { get; private set; } = 0;

		public PlayfieldMap PlayfieldMap { get; private set; } = null;

		// Playfield processor fields.
		private Thread processor;
		private bool process = true;
		private TimeSpan loopTime = new TimeSpan(0, 0, 1);

		// Playfield mapper fields.
		private Thread mapper;
		private Queue<Action<PlayfieldMap>> notifyWhenMapReady = new Queue<Action<PlayfieldMap>>();

		public PlayfieldProcessor(IPlayfield playfield)
		{
			if (playfield == null) throw new ArgumentException("Playfield processor passed a null playfield.", "playfield");

			this.Playfield = playfield;
			this.PlayfieldTokens = new PlayfieldTokenizer(playfield);

			Log.Info($"Launching thread to process entities in playfield {playfield.Name}.");

			this.processor = new Thread(this.ProcessPlayfield);
			this.processor.Name = $"DCE entity processor for playfield {playfield.Name}";
			this.processor.IsBackground = true;
			this.processor.Start();

			this.mapper = new Thread(this.MapPlayfield);
			this.mapper.Name = $"DCE mapper for playfield {playfield.Name}";
			this.mapper.IsBackground = true;
			this.mapper.Start();
		}

		/// <summary>
		/// Signals to the child thread to stop processing. Blocks for up to one second to allow the thread to finish.
		/// </summary>
		public void Stop()
		{
			this.process = false;
			this.processor.Join(1000);
		}

		/// <summary>
		/// Processes the playfield. Repeats processing until <see cref="process"/> is false. Each loop will take a minimum of <see cref="loopTime"/>. Intended to be launched in a thread.
		/// </summary>
		private void ProcessPlayfield()
		{
			DateTime loopStart;
			while (this.process)
			{
				if (this.Playfield == null) return;

				try
				{
					loopStart = DateTime.Now;
					//DarkCity.LogDebug($"Processing playfield {this.Playfield.Name}.");

					this.PlayfieldTokens.Update();

					this.ProcessEntities();

					// Done processing. Sleep thread for remaining loopTime.
					Thread.Sleep(loopTime - (DateTime.Now - loopStart));
				}
				catch (Exception ex)
				{
					Log.Critical($"Unhandled exception in entity processor for {this.Playfield.Name}: {ex.Message}" + Environment.NewLine + ex.StackTrace);
					Thread.Sleep(loopTime);
				}
			}

		}

		/// <summary>
		/// Processes IEntity instances from the playfield. Interesting entities are dispatched to other feature processeors for handling. Unhandled exceptions are caught here
		/// to prevent the mod from causing issues with the game server. If you want to add a new feature, hook it into the ProcessEntity method.
		/// </summary>
		private void ProcessEntities()
		{
			//DarkCity.LogDebug($"Processing entities in {this.Playfield.Name}.");
			Dictionary<int, IEntity> entities = this.Playfield.Entities;
			if (entities != null)
			{
				foreach (IEntity entity in entities.Values)
				{
					this.ProcessEntity(entity);
				}
			}
		}

		/// <summary>
		/// Examines an IEntity instance to see if any feature will be interested in it.
		/// </summary>
		/// <param name="entity">The IEntity instance to be examined.</param>
		private void ProcessEntity(IEntity entity)
		{
			if (entity == null) return;

			EntityTokenizer entityTokens = null;

			// Process structure data of the entity.
			IStructure structure = entity.Structure;
			if (structure != null)
			{
				//DarkCity.LogDebug($"Processing structure {structure.Entity.Name}");

				if (EmpyrionExtension.LiveLcd && 
					((EmpyrionExtension.Application.Mode == ApplicationMode.PlayfieldServer) || (EmpyrionExtension.Application.Mode == ApplicationMode.SinglePlayer)))
				{
					// Process LCD devices.
					IDevicePosList list = structure.GetDevices(DeviceTypeName.LCD);
					if (list != null)
					{
						for (int i = 0; i < list.Count; i++)
						{
							Eleon.Modding.VectorInt3 position = list.GetAt(i);
							ILcd lcd = structure.GetDevice<ILcd>(position);
							if (lcd != null)
							{
								// Prep structure tokens if not available yet.
								if (entityTokens == null)
									entityTokens = new EntityTokenizer(entity);

								// Hand off ILcd device to any potentially interested processors.
								LiveLcd.Process(structure, lcd, position, entityTokens, this.PlayfieldTokens);
							}
						}
					}
				}
			}
		}

		public void WhenMapReady(Action<PlayfieldMap> action)
		{
			if (this.notifyWhenMapReady != null)
				this.notifyWhenMapReady.Enqueue(action);
		}

		private void MapPlayfield()
		{
			try
			{
				Log.Info($"Mapping playfield {this.Playfield?.Name}.");

				PlayfieldMap map = new PlayfieldMap();
				map.Name = this.Playfield.Name;
				map.Resolution = this.MapResolution;

				// Probe playfield size by examining entity positions.
				Log.Info($"Calculating size of {this.Playfield.Name} using entity positions.");
				float xmin = float.MaxValue, xmax = float.MinValue, zmin = float.MaxValue, zmax = float.MinValue;
				if (this.Playfield?.Entities?.Values == null)
				{
					Log.Warn($"Playfield {this.Playfield.Name} has null entities. Cannot determine map size.");
					return;
				}

				foreach (IEntity entity in this.Playfield?.Entities?.Values)
				{
					if (entity == null) continue;
					xmin = Math.Min(xmin, entity.Position.x);
					xmax = Math.Max(xmax, entity.Position.x);
					zmin = Math.Min(zmin, entity.Position.z);
					zmax = Math.Max(zmax, entity.Position.z);
				}
				int xBounds = (int)Math.Max(Math.Abs(xmin), Math.Abs(xmax));
				int zBounds = (int)Math.Max(Math.Abs(zmin), Math.Abs(zmax));
				xBounds = (xBounds > 16000) ? 32000 : (xBounds > 8000) ? 16000 : (xBounds > 4000) ? 8000 : (xBounds > 2000) ? 4000 : 2000;
				zBounds = (zBounds > 8000) ? 16000 : (zBounds > 4000) ? 8000 : (zBounds > 2000) ? 4000 : (zBounds > 1000) ? 2000 : 1000;
				this.SizeClass = (int)Math.Log(xBounds / 1000, 2);

				Log.Info($"Playfield {this.Playfield.Name} is size class {this.SizeClass} and has bounds X: {xBounds}, Z: {zBounds}.");

				int dataWidth = (int)(xBounds * 2 / map.Resolution);
				int dataHeight = (int)(zBounds * 2 / map.Resolution);
				float[,] data = new float[dataWidth, dataHeight];
				float pfz; // z-coordinate translated to playfield coordinates. Avoid recalculating it for every x-coordinate.
				for (int z = 0; z < dataHeight; z++)
				{
					pfz = (z * map.Resolution) - zBounds;
					for (int x = 0; x < dataWidth; x++)
						data[x, z] = this.Playfield.GetTerrainHeightAt((x * map.Resolution) - xBounds, pfz) / map.Resolution;
				}

				map.HeightMap = data;
				this.PlayfieldMap = map;
				Log.Info($"Mapping of {this.Playfield.Name} is complete. With resolution {map.Resolution}, map is ({dataWidth}, {dataHeight}).");

				if (this.notifyWhenMapReady != null)
				{
					foreach (Action<PlayfieldMap> action in this.notifyWhenMapReady)
						action(map);
				}

				this.notifyWhenMapReady = null;
			} catch (Exception ex)
			{
				Log.Warn($"Failed to map {this.Playfield.Name}. Reason: {ex.Message}");
				throw;
			}
		}
	}
}
